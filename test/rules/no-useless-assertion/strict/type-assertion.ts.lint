export {};

<1>1;
~~~   [error no-useless-assertion: This assertion is unnecesary as it doesn't change the type of the expression.]
<number>1;
~~~~~~~~   [error no-useless-assertion: This assertion is unnecesary as it doesn't change the type of the expression.]
<number>(1 + 1);
~~~~~~~~         [error no-useless-assertion: This assertion is unnecesary as it doesn't change the type of the expression.]

let a: string = "foo";
a as typeof a;
  ~~~~~~~~~~~  [error no-useless-assertion: This assertion is unnecesary as it doesn't change the type of the expression.]
<string><string>a as string as string as string;
~~~~~~~~                                         [error no-useless-assertion: This assertion is unnecesary as it doesn't change the type of the expression.]
        ~~~~~~~~                                 [error no-useless-assertion: This assertion is unnecesary as it doesn't change the type of the expression.]
                  ~~~~~~~~~                      [error no-useless-assertion: This assertion is unnecesary as it doesn't change the type of the expression.]
                            ~~~~~~~~~            [error no-useless-assertion: This assertion is unnecesary as it doesn't change the type of the expression.]
                                      ~~~~~~~~~  [error no-useless-assertion: This assertion is unnecesary as it doesn't change the type of the expression.]
a as {} as number;
a as any;

let b = a ? a : undefined;
b as string;
b! as string;
   ~~~~~~~~~  [error no-useless-assertion: This assertion is unnecesary as it doesn't change the type of the expression.]

"".trim() as string;
          ~~~~~~~~~  [error no-useless-assertion: This assertion is unnecesary as it doesn't change the type of the expression.]

let c = !!b;
c as boolean;
  ~~~~~~~~~~  [error no-useless-assertion: This assertion is unnecesary as it doesn't change the type of the expression.]

interface I {
    prop: string;
    method(): number;
}

declare let d: I;
d as I;
  ~~~~  [error no-useless-assertion: This assertion is unnecesary as it doesn't change the type of the expression.]
d.method() as number;
           ~~~~~~~~~  [error no-useless-assertion: This assertion is unnecesary as it doesn't change the type of the expression.]

let e = "foo" as 'foo';
              ~~~~~~~~  [error no-useless-assertion: This assertion is unnecesary as it doesn't change the type of the expression.]
e as typeof e;
  ~~~~~~~~~~~  [error no-useless-assertion: This assertion is unnecesary as it doesn't change the type of the expression.]

['a', 'b', 'c'].map((element, i) => [i, element] as [number, string]);
let f: Array<[number, string]> = ['a', 'b', 'c'].map((element, i) => [i, element] as [number, string]);

interface NotATuple {
    0: number,
    0.5: number,
    2: number,
}

interface AlsoNotATuple {}

declare const notATuple: NotATuple;
<NotATuple>notATuple;
~~~~~~~~~~~           [error no-useless-assertion: This assertion is unnecesary as it doesn't change the type of the expression.]

declare const alsoNoTuple: AlsoNotATuple;
<AlsoNotATuple>alsoNoTuple;
~~~~~~~~~~~~~~~             [error no-useless-assertion: This assertion is unnecesary as it doesn't change the type of the expression.]

<any>unknownName;
~~~~~             [error no-useless-assertion: This assertion is unnecesary as it doesn't change the type of the expression.]

function fn<T extends string | undefined>(param: T) {
    param as string;
    param as string | undefined; // TODO get base constraint of type parameter
          ~~~~~~~~~~~~~~~~~~~~~                                                [error no-useless-assertion: This assertion is unnecesary as it doesn't change the type of the expression.]
    param as typeof param;
          ~~~~~~~~~~~~~~~  [error no-useless-assertion: This assertion is unnecesary as it doesn't change the type of the expression.]
    param!;
    b as T;
      ~~~~  [error no-useless-assertion: This assertion is unnecesary as it doesn't change the type of the expression.]
}
